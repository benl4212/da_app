'''
    feature_extraction.py
    
    - Desc: uses csv from st.file_uploader() to extract features 
            and save to cache for anomaly detection
    
    - Basic Features: 
        * Rolling window variance + standard deviation + sum
        * Rolling window sample entropy + approximate entropy
                
    - TSFRESH Features (Top 3 for each model generated by tsfresh_top_features.py)
        model       rank    feature
        IF          1,      value__quantile__q_0.1
                    2,      value__quantile__q_0.2 
                    3,      value__cwt_coefficients__coeff_11__w_5__widths_(2, 5, 10, 20) 
        OCSVM       1,      value__quantile__q_0.1 
                    2,      value__quantile__q_0.4 
                    3,      value__quantile__q_0.2 
        LOF         1,      value__fft_coefficient__attr_""imag""__coeff_52
                    2,      value__change_quantiles__f_agg_""mean""__isabs_False__qh_0.2__ql_0.0
                    3,      value__quantile__q_0.4
        
    - Frequency Domain Analysis        
        * Rolling Window FFT
        * Lomb-Scargle Periodgram (GPU accelerated) w/ power spectral density
        
    - Advanced Analysis
        * Continous Wavelet Transform
        * Lyapunov Exponents & Fractal Dimension
        * Recurrence Quantification Analysis (RQA) w/ determinism and laminarity
'''


import pandas as pd
import numpy as np
import streamlit as st
from tsfresh import extract_features
from tsfresh.utilities.dataframe_functions import impute
from tsfresh.feature_extraction import MinimalFCParameters

# Advanced Analysis Imports
from scipy import signal
import nolds
from pyrqa.time_series import TimeSeries
from pyrqa.settings import Settings
from pyrqa.computation import RQAComputation
import pywt # Using PyWavelets for CWT

# --- Original Rolling Features ---
@st.cache_data
def extract_rolling_features(df, window_size=10):
    """
    Calculates rolling window features (std dev, variance, sum) for numeric columns.
    """
    numeric_df = df.select_dtypes(include=['number'])
    all_feature_series = []
    for col in numeric_df.columns:
        rolling_window = numeric_df[col].rolling(window=window_size)
        std_dev_series = rolling_window.std().rename(f'{col}_std_dev')
        variance_series = rolling_window.var().rename(f'{col}_variance')
        sum_series = rolling_window.sum().rename(f'{col}_sum')
        all_feature_series.extend([std_dev_series, variance_series, sum_series])
    features_df = pd.concat(all_feature_series, axis=1)
    features_df.dropna(inplace=True)
    return features_df

# --- Rolling FFT Feature Function ---
@st.cache_data
def extract_rolling_fft(df, window_size=10):
    """
    Calculates rolling window FFT features (mean absolute coefficient).
    """
    numeric_df = df.select_dtypes(include=['number'])
    all_feature_series = []
    def fft_abs_mean(x):
        return np.mean(np.abs(np.fft.fft(x)))
    for col in numeric_df.columns:
        rolling_window = numeric_df[col].rolling(window=window_size)
        fft_series = rolling_window.apply(fft_abs_mean, raw=True).rename(f'{col}_fft_abs_mean')
        all_feature_series.append(fft_series)
    features_df = pd.concat(all_feature_series, axis=1)
    features_df.dropna(inplace=True)
    return features_df
    
# --- TSFRESH Feature Extraction Function ---
@st.cache_data
def extract_tsfresh_features(df):
    """
    Extracts a pre-defined set of high-value features using tsfresh.
    """
    numeric_df = df.select_dtypes(include=['number'])
    
    df_reset = numeric_df.reset_index()
    time_col_name = df_reset.columns[0]
    
    df_long = df_reset.melt(
        id_vars=time_col_name,
        var_name='id', 
        value_name='value'
    )
    
    df_long.rename(columns={time_col_name: 'time'}, inplace=True)

    # --- Tsfresh custom feature dictionary ---
    custom_fc_parameters = {
        "quantile": [{"q": 0.1}, {"q": 0.2}, {"q": 0.4}],
        "fft_coefficient": [{"attr": "imag", "coeff": 52}],
        "change_quantiles": [{"f_agg": "mean", "isabs": False, "qh": 0.2, "ql": 0.0}]
    }

    features_extracted = extract_features(
        df_long,
        column_id='id',
        column_sort='time',
        default_fc_parameters=custom_fc_parameters,
        disable_progressbar=True
    )
    
    impute(features_extracted)
    
    print(f"Tsfresh features extracted: {features_extracted.head()}")

    return features_extracted

# --- Generic Applicator & Advanced Feature Helper Functions ---

## Helper Functions (Operating on NumPy arrays)
def calculate_lombscargle_power(x):
    """Calculates the max power of the Lomb-Scargle periodogram."""
    if np.std(x) < 1e-6: return np.nan
    try:
        t = np.arange(len(x))
        freqs = np.linspace(0.01, 0.5, 100)
        pgram = signal.lombscargle(t, x, freqs, precenter=True)
        return np.max(pgram)
    except Exception:
        return np.nan

def calculate_cwt_energy(x):
    """Calculates the total energy of the CWT coefficients using PyWavelets."""
    if np.std(x) < 1e-6: return np.nan
    try:
        scales = np.arange(1, len(x) // 2)
        if len(scales) == 0: return np.nan
        coeffs, _ = pywt.cwt(x, scales, 'mexh')
        return np.sum(coeffs**2)
    except Exception:
        return np.nan

def calculate_lyapunov(x):
    """Calculates the largest Lyapunov exponent. Computationally expensive."""
    if np.std(x) < 1e-6: return np.nan
    try:
        return nolds.lyap_r(x)
    except Exception:
        return np.nan

def calculate_fractal_dimension(x):
    """Calculates the Higuchi Fractal Dimension."""
    if np.std(x) < 1e-6: return np.nan
    try:
        return nolds.hfd(x)
    except Exception:
        return np.nan

def _run_rqa(x):
    """Internal helper to avoid recomputing RQA for determinism and laminarity."""
    if np.std(x) < 1e-6: return None
    try:
        time_series = TimeSeries(x, embedding_dimension=2, time_delay=1)
        settings = Settings(time_series, similarity_measure='euclidean', neighbourhood_radius=0.5)
        computation = RQAComputation.create(settings, verbose=False)
        return computation.run()
    except Exception:
        return None

def calculate_rqa_determinism(x):
    """Calculates RQA Determinism (DET). Very computationally expensive."""
    result = _run_rqa(x)
    return result.determinism if result else np.nan

def calculate_rqa_laminarity(x):
    """Calculates RQA Laminarity (LAM). Very computationally expensive."""
    result = _run_rqa(x)
    return result.laminarity if result else np.nan

## Generic Rolling Window Applicator
@st.cache_data
def apply_custom_rolling_functions(df, window_size, _custom_funcs, selected_entity):
    """
    Applies a dictionary of custom functions to a rolling window for a SINGLE selected entity.
    """
    if selected_entity not in df.columns:
        st.warning(f"Column '{selected_entity}' not found for advanced feature calculation.")
        return pd.DataFrame()

    all_feature_series = []
    
    print(f"Applying {len(_custom_funcs)} custom functions to '{selected_entity}' with window size {window_size}...")
    
    rolling_window = df[selected_entity].rolling(window=window_size)
    
    for name, func in _custom_funcs.items():
        feature_series = rolling_window.apply(func, raw=True).rename(f'{selected_entity}_{name}')
        all_feature_series.append(feature_series)

    print("Finished applying custom functions.")
    if not all_feature_series:
        return pd.DataFrame()
        
    features_df = pd.concat(all_feature_series, axis=1)
    features_df.dropna(how='all', inplace=True)
    
    return features_df
